import pickle
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
"""This script is for analyzing all data from my model."""
"""NOTE: finaldata.pkl includes all packets generated in the region of interest
         1000finaldata.pkl includes packets generated by comm_pair that has a distance of less than 1000m
         thredata.pkl correct the transmission distance threshold
         update the figure size and for a whole second data
         2312data.pkl includes the pkt with higher receiving power level
         falpktrecpow.pkl includes the pkt with lower receiving power level."""

def walldist_dist_recpow(gs):
    """scatter plot of dist_recpow, categorized by walldist, and only include packets that distance < 1000m."""
    # groups of walldist
    r1 = gs[(gs['walldist'] == 0)]
    r2 = gs[(gs['walldist'] != 0)]
    # r2 = gs[(0 < gs['walldist']) & (gs['walldist'] < 100)]
    # r3 = gs[(100 <= gs['walldist']) & (gs['walldist'] < 200)]
    # r4 = gs[(200 <= gs['walldist']) & (gs['walldist'] < 300)]
    # r5 = gs[(300 <= gs['walldist']) & (gs['walldist'] < 400)]
    # r6 = gs[(400 <= gs['walldist']) & (gs['walldist'] < 500)]
    # r7 = gs[(500 <= gs['walldist']) & (gs['walldist'] < 600)]


    # data group
    G1 = (r1['dist'], r1['recpow'])
    G2 = (r2['dist'], r2['recpow'])
    # G3 = (r3['dist'], r3['recpow'])
    # G4 = (r4['dist'], r4['recpow'])
    # G5 = (r5['dist'], r5['recpow'])
    # G6 = (r6['dist'], r6['recpow'])
    # G7 = (r7['dist'], r7['recpow'])

    data = (G1, G2)
    groups = ("LOS", "NLOS")
    # data = (G1, G2, G3, G4, G5, G6, G7)
    # groups = ("LOS", "[0,100]", "[100,200]", "[200,300]", "[300,400]", "[400,500]", "[500,600]")

    
    fig, ax = plt.subplots(figsize=(6,4))
    # NOTE: If the packet receving power is below threshold, the module doesn't count its hidden terminal/neighbours.
    for data, group in zip(data, groups):
        x, y = data
        ax.scatter(x, y, alpha=0.8, cmap=plt.cm.get_cmap('tab20c', 2), s=0.5, label=group)
        # ax.scatter(x, y, alpha=0.8, cmap=plt.cm.get_cmap('tab20c', 7), s=0.5)
    plt.axhline(y=-89, color='r', linestyle='-')
    plt.grid(True)
    plt.xlabel('Distance [meter]')
    plt.ylabel('Receiving Power Level [dBm]')
    plt.legend(loc=1, markerscale=4, title='Transmission link type', prop={'size':8})
    fig.tight_layout()
    fig.savefig('1601walldist_dist_recpowLOS.png', dpi=300)
    plt.show()

def HT_dist_PER(gs):
    """scatter plot of dist_PER, categorized by hidden terminals, and only include packets that distance < 1000m."""
    # groups of hidden terminals
    g1 = gs[(gs['Hidden_Terminals'] < 10)]
    g2 = gs[(10 <= gs['Hidden_Terminals']) & (gs['Hidden_Terminals'] < 20)]
    g3 = gs[(20 <= gs['Hidden_Terminals']) & (gs['Hidden_Terminals'] < 30)]
    g4 = gs[(30 <= gs['Hidden_Terminals']) & (gs['Hidden_Terminals'] < 40)]
   
    # data group
    G1 = (g1['dist'], 1-g1['Prob_RP'])
    G2 = (g2['dist'], 1-g2['Prob_RP'])
    G3 = (g3['dist'], 1-g3['Prob_RP'])
    G4 = (g4['dist'], 1-g4['Prob_RP'])
    

    data = (G1, G2, G3, G4)
    groups = ("[0,10]", "[10,20]", "[20,30]", "[30,40]")

    fig, ax = plt.subplots(figsize=(6,4))
    # NOTE: If the packet receving power is below threshold, the module doesn't count its hidden terminal/neighbours.
    for data, group in zip(data, groups):
        x, y = data
        ax.scatter(x, y, alpha=0.8, cmap=plt.cm.get_cmap('tab20c', 4), s=0.5, label=group)
    plt.grid(True)
    ax.set_ylim((-0.05, 1.05))
    ax.set_yticks(np.arange(0, 1.1, 0.1))
    # plt.title('Dist-PER scatter plot (categorized by Hidden_Terminals)')
    plt.xlabel('Distance [meter]')
    plt.ylabel('Total Collision Probability')
    plt.legend(loc=2, markerscale=4, title='Hidden Terminals', prop={'size': 8})
    fig.tight_layout()
    fig.savefig('2312HT_dist_PER.png', dpi=300)
    plt.show()

def NH_dist_PER(gs):
    """scatter plot of dist_PER, categorized by neighbours, and only include packets that distance < 1000m."""
    # groups of neighbours
    r1 = gs[(gs['Neighbours'] < 10)]
    r2 = gs[(10 <= gs['Neighbours']) & (gs['Neighbours'] < 20)]
    r3 = gs[(20 <= gs['Neighbours']) & (gs['Neighbours'] < 30)]
    r4 = gs[(30 <= gs['Neighbours']) & (gs['Neighbours'] < 40)]
    r5 = gs[(40 <= gs['Neighbours']) & (gs['Neighbours'] < 50)]
  

    # data group 
    G1 = (r1['dist'], 1-r1['Prob_RP'])
    G2 = (r2['dist'], 1-r2['Prob_RP'])
    G3 = (r3['dist'], 1-r3['Prob_RP'])
    G4 = (r4['dist'], 1-r4['Prob_RP'])
    G5 = (r5['dist'], 1-r5['Prob_RP'])
 
    
    data = (G1, G2, G3, G4, G5,)
    groups = ("[0,10]", "[10,20]", "[20,30]", "[30, 40]","[40,50]")    
    fig, ax = plt.subplots(figsize=(6,4))
    # NOTE: If the packet receving power is below threshold, the module doesn't count its hidden terminal/neighbours.
    for data, group in zip(data, groups):
        x, y = data
        ax.scatter(x, y, alpha=0.8, cmap=plt.cm.get_cmap('tab20c', 5), s=0.5, label=group)
    plt.grid(True)
    # plt.title('Dist-PER scatter plot (categorized by Neighbours)')
    ax.set_ylim((-0.05, 1.05))
    ax.set_yticks(np.arange(0, 1.1, 0.1))
    plt.xlabel('Distance [meter]')
    plt.ylabel('Total Collision Probability')
    plt.legend(loc=2, markerscale=4, title='Neighbours', prop={'size':8})
    fig.tight_layout()
    fig.savefig('2312NH_dist_PER.png', dpi=300)
    plt.show()

def wallnum_dist_recpow(gs):
    """scatter plot of dist_recpow, categorized by wallnum, and only include packets that distance < 1000m."""
    
    # groups of walldist
    r1 = gs[(gs['wallnum'] == 0)]
    r2 = gs[(0 < gs['wallnum']) & (gs['wallnum'] < 20)]
    r3 = gs[(20 <= gs['wallnum']) & (gs['wallnum'] < 40)]
    r4 = gs[(40 <= gs['wallnum']) & (gs['wallnum'] < 60)]
    r5 = gs[(60 <= gs['wallnum']) & (gs['wallnum'] < 80)]
    r6 = gs[(80 <= gs['wallnum']) & (gs['wallnum'] < 100)]

    # data group
    G1 = (r1['dist'], r1['recpow'])
    G2 = (r2['dist'], r2['recpow'])
    G3 = (r3['dist'], r3['recpow'])
    G4 = (r4['dist'], r4['recpow'])
    G5 = (r5['dist'], r5['recpow'])
    G6 = (r6['dist'], r6['recpow'])
    data = (G1, G2, G3, G4, G5, G6)
    groups = ("LOS", "[0,20]", "[20,40]", "[40,60]", "[60,80]", "[80, 100]")

    fig, ax = plt.subplots(figsize=(6,4))
    # NOTE: If the packet receving power is below threshold, the module doesn't count its hidden terminal/neighbours.
    for data, group in zip(data, groups):
        x, y = data
        ax.scatter(x, y, alpha=0.8, cmap=plt.cm.get_cmap('tab20c', 6), s=0.5, label=group)
    plt.axhline(y=-89, color='r', linestyle='-')
    plt.grid(True)
    # plt.title('Dist-rec_pow scatter plot (categorized by Wall_num)')
    plt.xlabel('Distance [meter]')
    plt.ylabel('Receiving Power Level [dBm]')
    plt.legend(loc=1, markerscale=4, title='Wall Numbers', prop={'size':8})
    fig.tight_layout()
    fig.savefig('2312wallnum_dist_recpow.png', dpi=300)
    plt.show()

if __name__ == '__main__':
    with open('2312data.pkl', 'rb') as f, open('falpktrecpow.pkl', 'rb') as f2:
        df1 = pickle.load(f)
        df2 = pickle.load(f2)
    df1.Prob_RP=df1.Prob_RP.astype(float)
    # maximum number of neighbours in all results
    print(np.nanmax(df1.loc[:, ['Neighbours']].values))
    # maximum number of hidden terminals in all results
    print(np.nanmax(df1.loc[:, ['Hidden_Terminals']].values))

    #  scatter plot of distance_per, categorized by hidden terminals
    # HT_dist_PER(df1)
    # #  scatter plot of distance_per, categorized by neighbours
    # NH_dist_PER(df1)
    



    df2 = df2.rename({0: 'recpow', 1: 'dist', 2: 'walldist', 3: 'wallnum'})
    dffail = df2.T
    dffail.insert(4, 'Prob_RP', 0)
    # print(dffail)
    dfsucc = df1.filter(['recpow', 'dist', 'walldist', 'wallnum', 'Prob_RP'], axis=1)
    frames = [dfsucc, dffail]
    result = pd.concat(frames)

    # maximum value of walldist in all results
    print(np.nanmax(result.loc[:, ['walldist']].values))
    # maximum value of wallnum in all results
    print(np.nanmax(result.loc[:, ['wallnum']].values))
    # scatter plot of distance_recpow, categorized by walldistance, do it in allpktdraw.py
    walldist_dist_recpow(result)
    # scatter plot of distance_recpow, categorized by wallnum, do it in allpktdraw.py
    # wallnum_dist_recpow(result)

    fig, ax = plt.subplots(figsize=(6,4))
    ax.scatter(result['dist'], result['recpow'], s=0.5)
    plt.axhline(y=-89, color='r', linestyle='-')
    plt.grid(True)
    plt.xlabel('Distance [meter]')
    plt.ylabel('Receiving Power Level [dBm]')
    fig.tight_layout()
    # fig.savefig('2312dist_recpow.png', dpi=300)
    plt.show()

    fig, ax = plt.subplots(figsize=(6,4))
    ax.scatter(result['dist'], 1 - result['Prob_RP'], s=0.5)
    ax.set_yticks(np.arange(0, 1.1, 0.1))
    plt.grid(True)
    plt.xlabel('Distance [meter]')
    plt.ylabel('Total Collision Probability')
    fig.tight_layout()
    # fig.savefig('1001dist_per.png', dpi=300)
    plt.show()
##################################################################
    # plot of hidden_terminals and packet error rate
    fig, ax = plt.subplots(figsize=(6,4))
    ax.scatter(df1['Hidden_Terminals'], 1-df1['Prob_RP'], s=0.5)
    ax.set_ylim((-0.05, 1.05))
    ax.set_yticks(np.arange(0, 1.1, 0.1))
    ax.grid(True)
    ax.set_xlabel('Number of Hidden Terminals')
    ax.set_ylabel('Total Collision Probability')
    fig.tight_layout()
    # fig.savefig('2312HT_PER.png', dpi=300)
    plt.show()
##################################################################
# plot of neighbours and packet error rate
    fig, ax = plt.subplots(figsize=(6,4))
    plt.scatter(df1['Neighbours'], 1-df1['Prob_RP'], s=0.5)
    ax.set_xlim((-2.5, 50))
    ax.set_ylim((-0.05, 1.05))
    ax.set_yticks(np.arange(0, 1.1, 0.1)) 
    plt.grid(True)
    # plt.title('Neighbours-PER scatter plot (dist < 1000)')
    plt.xlabel('Number of Neighbours')
    plt.ylabel('Total Collision Probability')
    fig.tight_layout()
    fig.savefig('1501NH_PER.png', dpi=300)
    plt.show()
